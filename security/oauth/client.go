package oauth

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
)

// Client implements OAuth client functionality
type Client struct {
	config       *Config
	httpClient   *http.Client
	stateManager *StateManager
}

// NewClient creates a new OAuth client
func NewClient(config *Config) *Client {
	if config.StateSecret == "" {
		config.StateSecret = "default-secret" // Should be configured
	}

	return &Client{
		config: config,
		httpClient: &http.Client{
			Timeout: 30 * time.Second,
		},
		stateManager: NewStateManager(config.StateSecret),
	}
}

// GetAuthURL generates OAuth authorization URL
func (c *Client) GetAuthURL(provider Provider, state string, additionalParams map[string]string) (string, error) {
	config, exists := c.config.Providers[string(provider)]
	if !exists || !config.Enabled {
		return "", fmt.Errorf("OAuth provider %s not configured or disabled", provider)
	}

	if state == "" {
		stateData := &StateData{
			Provider: string(provider),
			Action:   "login",
		}
		var err error
		state, err = c.stateManager.GenerateState(stateData)
		if err != nil {
			return "", err
		}
	}

	params := url.Values{
		"client_id":     {config.ClientID},
		"redirect_uri":  {config.RedirectURL},
		"scope":         {strings.Join(config.Scopes, " ")},
		"response_type": {"code"},
		"state":         {state},
	}

	// Add PKCE if enabled and supported
	if c.config.EnablePKCE && c.supportsPKCE(provider) {
		// PKCE should be generated by the caller and stored in state
		// This is a simplified implementation
		if additionalParams["code_challenge"] != "" {
			params.Set("code_challenge", additionalParams["code_challenge"])
			params.Set("code_challenge_method", "S256")
		}
	}

	// Add provider-specific parameters
	switch provider {
	case ProviderGoogle:
		params.Set("access_type", "offline")
		params.Set("prompt", "consent")
	case ProviderGitHub:
		params.Set("allow_signup", "true")
	case ProviderMicrosoft:
		params.Set("response_mode", "query")
	case ProviderApple:
		params.Set("response_mode", "form_post")
	}

	// Add extra params from config
	for key, value := range config.ExtraParams {
		params.Set(key, value)
	}

	// Add additional parameters
	for key, value := range additionalParams {
		if key != "code_challenge" { // Already handled above
			params.Set(key, value)
		}
	}

	return fmt.Sprintf("%s?%s", config.AuthURL, params.Encode()), nil
}

// ExchangeCodeForToken exchanges authorization code for access token
func (c *Client) ExchangeCodeForToken(ctx context.Context, provider Provider, code string, codeVerifier ...string) (*TokenResponse, error) {
	config, exists := c.config.Providers[string(provider)]
	if !exists || !config.Enabled {
		return nil, fmt.Errorf("OAuth provider %s not configured or disabled", provider)
	}

	data := url.Values{
		"client_id":     {config.ClientID},
		"client_secret": {config.ClientSecret},
		"code":          {code},
		"grant_type":    {"authorization_code"},
		"redirect_uri":  {config.RedirectURL},
	}

	// Add PKCE code verifier if provided
	if len(codeVerifier) > 0 && codeVerifier[0] != "" {
		data.Set("code_verifier", codeVerifier[0])
	}

	req, err := http.NewRequestWithContext(ctx, "POST", config.TokenURL, strings.NewReader(data.Encode()))
	if err != nil {
		return nil, err
	}

	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
	req.Header.Set("Accept", "application/json")

	// Some providers require Basic Auth
	if provider == ProviderApple || provider == ProviderTwitter {
		req.SetBasicAuth(config.ClientID, config.ClientSecret)
	}

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("token exchange failed: %s", string(body))
	}

	var tokenResp TokenResponse
	if err := json.NewDecoder(resp.Body).Decode(&tokenResp); err != nil {
		return nil, err
	}

	// Calculate expiration time
	if tokenResp.ExpiresIn > 0 {
		tokenResp.ExpiresAt = time.Now().Add(time.Duration(tokenResp.ExpiresIn) * time.Second)
	}

	return &tokenResp, nil
}

// RefreshAccessToken refreshes access token using refresh token
func (c *Client) RefreshAccessToken(ctx context.Context, provider Provider, refreshToken string) (*TokenResponse, error) {
	config, exists := c.config.Providers[string(provider)]
	if !exists || !config.Enabled {
		return nil, fmt.Errorf("OAuth provider %s not configured or disabled", provider)
	}

	data := url.Values{
		"client_id":     {config.ClientID},
		"client_secret": {config.ClientSecret},
		"refresh_token": {refreshToken},
		"grant_type":    {"refresh_token"},
	}

	req, err := http.NewRequestWithContext(ctx, "POST", config.TokenURL, strings.NewReader(data.Encode()))
	if err != nil {
		return nil, err
	}

	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
	req.Header.Set("Accept", "application/json")

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("token refresh failed: %s", string(body))
	}

	var tokenResp TokenResponse
	if err := json.NewDecoder(resp.Body).Decode(&tokenResp); err != nil {
		return nil, err
	}

	// Calculate expiration time
	if tokenResp.ExpiresIn > 0 {
		tokenResp.ExpiresAt = time.Now().Add(time.Duration(tokenResp.ExpiresIn) * time.Second)
	}

	return &tokenResp, nil
}

// GetUserProfile gets user profile from OAuth provider
func (c *Client) GetUserProfile(ctx context.Context, provider Provider, accessToken string) (*Profile, error) {
	config, exists := c.config.Providers[string(provider)]
	if !exists || !config.Enabled {
		return nil, fmt.Errorf("OAuth provider %s not configured or disabled", provider)
	}

	// Handle special cases
	switch provider {
	case ProviderGitHub:
		return c.getGitHubProfile(ctx, accessToken)
	case ProviderApple:
		return c.getAppleProfile(ctx, accessToken)
	case ProviderTwitter:
		return c.getTwitterProfile(ctx, accessToken)
	case ProviderLinkedIn:
		return c.getLinkedInProfile(ctx, accessToken)
	}

	userInfoURL := config.UserInfoURL

	// Add provider-specific parameters
	if provider == ProviderFacebook {
		userInfoURL += "?fields=id,name,email,picture,verified"
	}

	req, err := http.NewRequestWithContext(ctx, "GET", userInfoURL, nil)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", "Bearer "+accessToken)
	req.Header.Set("Accept", "application/json")

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("failed to get user profile: %s", string(body))
	}

	var rawProfile map[string]any
	if err := json.NewDecoder(resp.Body).Decode(&rawProfile); err != nil {
		return nil, err
	}

	profile := c.parseProfile(provider, rawProfile)
	if profile.ID == "" {
		return nil, fmt.Errorf("invalid profile data from OAuth provider: missing ID")
	}

	return profile, nil
}

// ValidateToken validates an access token
func (c *Client) ValidateToken(ctx context.Context, provider Provider, token string) (*TokenInfo, error) {
	// Implementation depends on provider capabilities
	// This is a basic implementation
	profile, err := c.GetUserProfile(ctx, provider, token)
	if err != nil {
		return &TokenInfo{Valid: false}, nil
	}

	return &TokenInfo{
		Valid:    profile != nil,
		ClientID: c.config.Providers[string(provider)].ClientID,
	}, nil
}

// RevokeToken revokes an access token
func (c *Client) RevokeToken(ctx context.Context, provider Provider, token string) error {
	config, exists := c.config.Providers[string(provider)]
	if !exists || !config.Enabled || config.RevokeURL == "" {
		return fmt.Errorf("token revocation not supported for provider %s", provider)
	}

	data := url.Values{
		"token": {token},
	}

	req, err := http.NewRequestWithContext(ctx, "POST", config.RevokeURL, strings.NewReader(data.Encode()))
	if err != nil {
		return err
	}

	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
	req.SetBasicAuth(config.ClientID, config.ClientSecret)

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return fmt.Errorf("token revocation failed: %s", string(body))
	}

	return nil
}

// Helper methods

func (c *Client) supportsPKCE(provider Provider) bool {
	info := GetProviderInfo(string(provider))
	return info.SupportsPKCE
}

func (c *Client) parseProfile(provider Provider, rawProfile map[string]any) *Profile {
	profile := &Profile{Provider: string(provider)}

	switch provider {
	case ProviderGoogle:
		profile.ID = getString(rawProfile, "sub")
		profile.Email = getString(rawProfile, "email")
		profile.Name = getString(rawProfile, "name")
		profile.Avatar = getString(rawProfile, "picture")
		profile.Username = getString(rawProfile, "email")
		profile.Verified = getBool(rawProfile, "email_verified")
		profile.Locale = getString(rawProfile, "locale")

	case ProviderFacebook:
		profile.ID = getString(rawProfile, "id")
		profile.Email = getString(rawProfile, "email")
		profile.Name = getString(rawProfile, "name")
		profile.Username = getString(rawProfile, "email")
		profile.Verified = getBool(rawProfile, "verified")
		if picture, ok := rawProfile["picture"].(map[string]any); ok {
			if data, ok := picture["data"].(map[string]any); ok {
				profile.Avatar = getString(data, "url")
			}
		}

	case ProviderMicrosoft:
		profile.ID = getString(rawProfile, "id")
		profile.Email = getString(rawProfile, "mail")
		if profile.Email == "" {
			profile.Email = getString(rawProfile, "userPrincipalName")
		}
		profile.Name = getString(rawProfile, "displayName")
		profile.Username = profile.Email
	case ProviderTikTok:
		if data, ok := rawProfile["data"].(map[string]any); ok {
			profile.ID = getString(data, "open_id")
			profile.Name = getString(data, "display_name")
			profile.Username = getString(data, "username")
			profile.Avatar = getString(data, "avatar_url")
		}

	case ProviderWeChat:
		profile.ID = getString(rawProfile, "openid")
		profile.Name = getString(rawProfile, "nickname")
		profile.Avatar = getString(rawProfile, "headimgurl")
		profile.Username = getString(rawProfile, "openid")

	case ProviderAlipay:
		profile.ID = getString(rawProfile, "user_id")
		profile.Name = getString(rawProfile, "nick_name")
		profile.Avatar = getString(rawProfile, "avatar")
		profile.Username = getString(rawProfile, "user_id")

	case ProviderBaidu:
		profile.ID = getString(rawProfile, "uid")
		profile.Name = getString(rawProfile, "uname")
		profile.Username = getString(rawProfile, "uname")

	case ProviderWeibo:
		profile.ID = getString(rawProfile, "id")
		profile.Name = getString(rawProfile, "screen_name")
		profile.Avatar = getString(rawProfile, "profile_image_url")
		profile.Username = getString(rawProfile, "name")
		profile.Verified = getBool(rawProfile, "verified")

	case ProviderQQ:
		profile.ID = getString(rawProfile, "openid")
		profile.Name = getString(rawProfile, "nickname")
		profile.Avatar = getString(rawProfile, "figureurl_qq_1")
		profile.Username = getString(rawProfile, "openid")

	default:
		// Generic parsing for custom providers
		profile.ID = getString(rawProfile, "id")
		profile.Email = getString(rawProfile, "email")
		profile.Name = getString(rawProfile, "name")
		profile.Avatar = getString(rawProfile, "avatar")
		profile.Username = getString(rawProfile, "username")
		if profile.Username == "" {
			profile.Username = profile.Email
		}
	}

	return profile
}

// getGitHubProfile handles GitHub's special case for email
func (c *Client) getGitHubProfile(ctx context.Context, accessToken string) (*Profile, error) {
	// Get basic profile
	req, err := http.NewRequestWithContext(ctx, "GET", "https://api.github.com/user", nil)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", "Bearer "+accessToken)
	req.Header.Set("Accept", "application/json")

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var profile map[string]any
	if err := json.NewDecoder(resp.Body).Decode(&profile); err != nil {
		return nil, err
	}

	// Get email separately if not provided
	email := getString(profile, "email")
	if email == "" {
		email, _ = c.getGitHubEmail(ctx, accessToken)
	}

	return &Profile{
		ID:       fmt.Sprintf("%v", profile["id"]),
		Email:    email,
		Name:     getString(profile, "name"),
		Avatar:   getString(profile, "avatar_url"),
		Username: getString(profile, "login"),
		Provider: string(ProviderGitHub),
		Verified: getBool(profile, "email_verified"),
	}, nil
}

// getGitHubEmail gets primary email from GitHub
func (c *Client) getGitHubEmail(ctx context.Context, accessToken string) (string, error) {
	req, err := http.NewRequestWithContext(ctx, "GET", "https://api.github.com/user/emails", nil)
	if err != nil {
		return "", err
	}

	req.Header.Set("Authorization", "Bearer "+accessToken)
	req.Header.Set("Accept", "application/json")

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	var emails []map[string]any
	if err := json.NewDecoder(resp.Body).Decode(&emails); err != nil {
		return "", err
	}

	// Find primary email
	for _, email := range emails {
		if primary, ok := email["primary"].(bool); ok && primary {
			if addr, ok := email["email"].(string); ok {
				return addr, nil
			}
		}
	}

	// Fallback to first verified email
	for _, email := range emails {
		if verified, ok := email["verified"].(bool); ok && verified {
			if addr, ok := email["email"].(string); ok {
				return addr, nil
			}
		}
	}

	// Fallback to first email
	if len(emails) > 0 {
		if addr, ok := emails[0]["email"].(string); ok {
			return addr, nil
		}
	}

	return "", fmt.Errorf("no email found")
}

// getAppleProfile handles Apple Sign In profile
func (c *Client) getAppleProfile(ctx context.Context, accessToken string) (*Profile, error) {
	// Apple doesn't provide a user info endpoint
	// Profile data is typically provided in the ID token during the initial auth
	// This is a placeholder implementation
	return &Profile{
		Provider: string(ProviderApple),
	}, fmt.Errorf("Apple profile retrieval requires ID token parsing")
}

// getTwitterProfile handles Twitter profile
func (c *Client) getTwitterProfile(ctx context.Context, accessToken string) (*Profile, error) {
	req, err := http.NewRequestWithContext(ctx, "GET", "https://api.twitter.com/2/users/me?user.fields=profile_image_url,verified", nil)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", "Bearer "+accessToken)
	req.Header.Set("Accept", "application/json")

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var result map[string]any
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, err
	}

	data, ok := result["data"].(map[string]any)
	if !ok {
		return nil, fmt.Errorf("invalid Twitter API response")
	}

	return &Profile{
		ID:       getString(data, "id"),
		Name:     getString(data, "name"),
		Username: getString(data, "username"),
		Avatar:   getString(data, "profile_image_url"),
		Provider: string(ProviderTwitter),
		Verified: getBool(data, "verified"),
	}, nil
}

// getLinkedInProfile handles LinkedIn profile
func (c *Client) getLinkedInProfile(ctx context.Context, accessToken string) (*Profile, error) {
	// Get basic profile
	req, err := http.NewRequestWithContext(ctx, "GET", "https://api.linkedin.com/v2/people/~:(id,firstName,lastName,profilePicture(displayImage~:playableStreams))", nil)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", "Bearer "+accessToken)
	req.Header.Set("Accept", "application/json")

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var profile map[string]any
	if err := json.NewDecoder(resp.Body).Decode(&profile); err != nil {
		return nil, err
	}

	// Get email
	email, _ := c.getLinkedInEmail(ctx, accessToken)

	// Parse name
	var name string
	if firstName, ok := profile["firstName"].(map[string]any); ok {
		if localized, ok := firstName["localized"].(map[string]any); ok {
			for _, v := range localized {
				if str, ok := v.(string); ok {
					name = str
					break
				}
			}
		}
	}
	if lastName, ok := profile["lastName"].(map[string]any); ok {
		if localized, ok := lastName["localized"].(map[string]any); ok {
			for _, v := range localized {
				if str, ok := v.(string); ok {
					if name != "" {
						name += " "
					}
					name += str
					break
				}
			}
		}
	}

	return &Profile{
		ID:       getString(profile, "id"),
		Email:    email,
		Name:     name,
		Username: email,
		Provider: string(ProviderLinkedIn),
	}, nil
}

// getLinkedInEmail gets email from LinkedIn
func (c *Client) getLinkedInEmail(ctx context.Context, accessToken string) (string, error) {
	req, err := http.NewRequestWithContext(ctx, "GET", "https://api.linkedin.com/v2/emailAddress?q=members&projection=(elements*(handle~))", nil)
	if err != nil {
		return "", err
	}

	req.Header.Set("Authorization", "Bearer "+accessToken)
	req.Header.Set("Accept", "application/json")

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	var result map[string]any
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return "", err
	}

	if elements, ok := result["elements"].([]any); ok && len(elements) > 0 {
		if element, ok := elements[0].(map[string]any); ok {
			if handle, ok := element["handle~"].(map[string]any); ok {
				return getString(handle, "emailAddress"), nil
			}
		}
	}

	return "", fmt.Errorf("no email found")
}
